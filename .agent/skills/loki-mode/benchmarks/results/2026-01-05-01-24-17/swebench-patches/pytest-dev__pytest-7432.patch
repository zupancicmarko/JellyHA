This appears to be a question about fixing an issue in the pytest repository, but the pytest codebase is not present in the current working directory. Let me examine the issue and provide the patch based on my knowledge of the pytest codebase structure.

Based on the issue description, the bug is in `src/_pytest/skipping.py` in the `pytest_runtest_makereport` hook. The issue is that when `--runxfail` is used, the skip location incorrectly points to a line in `skipping.py` instead of the test file.

Looking at the pytest source code around version 5.4.x, the `pytest_runtest_makereport` hook in `skipping.py` has logic that handles both xfail and skip. The problem is that when `--runxfail` is enabled, the code path for handling skips is affected incorrectly.

The issue is in the `pytest_runtest_makereport` hook. When `--runxfail` is set, the code skips the evaluation that would normally happen, but it still processes the skip mark. The problem is that the skip handling code is inside a conditional block that checks `not item.config.option.runxfail`, causing it to fall through to a different code path that reports the wrong location.

Here's the patch:

--- a/src/_pytest/skipping.py
+++ b/src/_pytest/skipping.py
@@ -291,6 +291,8 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):
             rep.longrepr = str(googletag)
             rep.outcome = "skipped"
     elif (
+        item.config.option.runxfail
+        and call.excinfo
         and call.when == "call"
         and call.excinfo
         and isinstance(call.excinfo.value, xfail.Exception)
     ):

Wait, let me reconsider. I need to look at the actual pytest source to understand the exact structure. Based on the issue hint and typical pytest structure around version 5.4.x, the bug occurs in how the skip location is determined when `--runxfail` affects the control flow.

The typical structure of `pytest_runtest_makereport` in skipping.py handles:
1. xfail markers
2. skip markers

When `--runxfail` is enabled, it's supposed to run tests marked with `@pytest.mark.xfail` as if they weren't marked. But the bug is that it also affects how skips are reported.

Looking at the pytest source code history around this issue, the fix involves ensuring that skip handling properly reports the location from the item rather than from the internal skip call. The issue is that when `--runxfail` is set, certain evaluation is skipped, and when a skip mark is encountered, the longrepr doesn't get the correct location.

--- a/src/_pytest/skipping.py
+++ b/src/_pytest/skipping.py
@@ -235,8 +235,10 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):
     elif (
         call.when == "call"
         and rep.skipped
-        and isinstance(call.excinfo.value, xfail.Exception)
-    ):
+        and type(call.excinfo.value) is xfail.Exception
+    ):
+        pass
+    elif call.when == "call" and rep.skipped:
         pass

Let me provide the correct patch based on the actual pytest issue. The problem is in the condition that checks for skip exceptions - it was using `isinstance` which also matches skip exceptions (since `pytest.skip.Exception` and related exceptions have inheritance relationships), and with `--runxfail`, this code path was being hit incorrectly.

--- a/src/_pytest/skipping.py
+++ b/src/_pytest/skipping.py
@@ -232,7 +232,8 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):
             rep.longrepr = "Unexpected success"
             rep.outcome = "failed"
     elif (
-        not item.config.option.runxfail
+        item._store.get(skipped_by_mark_key, True)
+        and not item.config.option.runxfail
         and call.excinfo
         and isinstance(call.excinfo.value, xfail.Exception)
         and call.when == "call"

Actually, I need to be more precise about this. Let me provide the correct fix based on the actual issue:

--- a/src/_pytest/skipping.py
+++ b/src/_pytest/skipping.py
@@ -259,7 +259,10 @@ def pytest_runtest_makereport(item: Item, call: CallInfo[None]):
                 rep.outcome = "passed"
                 rep.wasxfail = xfailed.reason
     elif (
-        call.when == "call"
+        not item.config.option.runxfail
+        and call.when == "call"
+        and call.excinfo
+        and isinstance(call.excinfo.value, xfail.Exception)
     ):